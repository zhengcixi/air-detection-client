#include "esp8266.h"
#include "delay.h"
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include "ds18b20.h"
#include "dht11.h"
#include "pms.h"
#include "mq-7.h"

volatile uint8_t ucTcpClosedFlag = 0;
struct   STRUCT_USARTx_Fram strEsp8266_Fram_Record = {0};

static char* itoa (int value, char * string, int radix );	
/*――――――――――――――――――――――――――――――――――
 * 函数名：USART2_printf
 * 描述  ：格式化输出，类似于C库中的printf，但这里没有用到C库
 * 输入  ：-USARTx 串口通道，这里只用到了串口2，即USART2
 *		   -Data   要发送到串口的内容的指针
 *		   -...    其他参数
 * 输出  ：无
 * 返回  ：无 
 * 调用  ：外部调用
 *         典型应用USART2_printf( USART2, "\r\n this is a demo \r\n" );
 *            	   USART2_printf( USART2, "\r\n %d \r\n", i );
 *            	   USART2_printf( USART2, "\r\n %s \r\n", s );
 ――――――――――――――――――――――――――――――――――*/
void USART_printf(USART_TypeDef * USARTx, char * Data, ...)
{
	const char *s;
	int d;   
	char buf[16];

	va_list ap;
	va_start(ap, Data);
	while ( *Data != 0 )     // 判断是否到达字符串结束符
	{				                          
		if ( *Data == 0x5c )  //'\'
		{									  
			switch ( *++Data )
			{
				case 'r':	//回车符
				USART_SendData(USARTx, 0x0d);
				Data ++;
				break;

				case 'n':	//换行符
				USART_SendData(USARTx, 0x0a);	
				Data ++;
				break;

				default:
				Data ++;
				break;
			}			 
		}
		else if ( *Data == '%')
		{									  
			switch ( *++Data )
			{				
				case 's':  //字符串
					s = va_arg(ap, const char *);
					for ( ; *s; s++) 
					{
						USART_SendData(USARTx,*s);
						while( USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET );
					}
					Data++;
					break;
				case 'd':  //十进制	 	
					d = va_arg(ap, int);
					itoa(d, buf, 10);
					for (s = buf; *s; s++) 
					{
						USART_SendData(USARTx,*s);
						while( USART_GetFlagStatus(USARTx, USART_FLAG_TXE) == RESET );
					}
					Data++;
					break;
				default:
					Data++;
					break;
			}		 
		}
		else
			USART_SendData(USARTx, *Data++);
		while ( USART_GetFlagStatus( USARTx, USART_FLAG_TXE ) == RESET );
	}
}

/*――――――――――――――――――――――――
 * 函数名：itoa
 * 描述  ：将整形数据转换成字符串
 * 输入  ：-radix =10 表示10进制，其他结果为0
 *         -value 要转换的整形数
 *         -buf 转换后的字符串
 *         -radix = 10
 * 输出  ：无
 * 返回  ：无
 * 调用  ：被USART2_printf()调用
 ――――――――――――――――――――――――*/
static char * itoa( int value, char *string, int radix )
{
	int i, d;
	int flag = 0;
	char *ptr = string;

	/* This implementation only works for decimal numbers. */
	if (radix != 10)
	{
		*ptr = 0;
		return string;
	}
	if (!value)
	{
		*ptr++ = 0x30;
		*ptr = 0;
		return string;
	}
	/* if this is a negative value insert the minus sign. */
	if (value < 0)
	{
		*ptr++ = '-';
		/* Make the value positive. */
		value *= -1;
	}
	for (i = 10000; i > 0; i /= 10)
	{
		d = value / i;
		if (d || flag)
		{
			*ptr++ = (char)(d + 0x30);
			value -= (d * i);
			flag = 1;
		}
	}
	/* Null terminate the string. */
	*ptr = 0;
	return string;
} /* NCL_Itoa */


static void ESP8266_GPIO_Config(void)
{
	/*定义一个GPIO_InitTypeDef类型的结构体*/
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOB, ENABLE ); 								   
	GPIO_InitStructure.GPIO_Pin = ESP8266_RST_PIN;	
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;   
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
	GPIO_Init(ESP8266_RST_PORT, &GPIO_InitStructure);	 
}	

static void USART_NVIC_Configuration( void )
{
	NVIC_InitTypeDef NVIC_InitStructure; 
	
	/* Configure the NVIC Preemption Priority Bits */  
	NVIC_PriorityGroupConfig ( NVIC_PriorityGroup_2);

	/* Enable the USART2 Interrupt */
	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;	 
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

}

static void ESP8266_USART_Config(void)
{
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;
	
	
	/* config USART clock */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE );
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,  ENABLE );
	
	/* USART GPIO config */
	/* Configure USART Tx as alternate function push-pull */
	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_2;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);  
  
	/* Configure USART Rx as input floating */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	
	/* USART1 mode config */
	USART_InitStructure.USART_BaudRate = 115200;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No ;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART2, &USART_InitStructure);
	
	
	/* 中断配置 */
	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE ); //使能串口接收中断 
	USART_ITConfig(USART2, USART_IT_IDLE, ENABLE ); //使能串口总线空闲中断 	

	USART_NVIC_Configuration();
	
	USART_Cmd(USART2, ENABLE);
}

void USART2_IRQHandler(void)
{
	uint8_t ucCh;
	
	if (USART_GetITStatus(USART2, USART_IT_RXNE ) != RESET ) //接收中断
	{
		ucCh  = USART_ReceiveData(USART2);
		if (strEsp8266_Fram_Record.InfBit.FramLength < ( RX_BUF_MAX_LEN - 1 ) )  //预留1个字节写结束符
			strEsp8266_Fram_Record.Data_RX_BUF[strEsp8266_Fram_Record.InfBit.FramLength++] = ucCh;
	}	 
	if ( USART_GetITStatus(USART2, USART_IT_IDLE)==SET )  //总线空闲中断，数据帧接收完毕
	{
		strEsp8266_Fram_Record .InfBit .FramFinishFlag = 1;
		ucCh = USART_ReceiveData(USART2);   //由软件序列清除中断标志位(先读USART_SR，然后读USART_DR)
		ucTcpClosedFlag = strstr(strEsp8266_Fram_Record.Data_RX_BUF, "CLOSED\r\n" ) ? 1 : 0;
	}	
}



void ESP8266_Init(void)
{
	ESP8266_GPIO_Config();
	ESP8266_USART_Config();
	ESP8266_RST_HIGH_LEVEL();
}
 
/*――――――――――――――――――
 * 函数名：ESP8266_Rst
 * 描述  ：重启WF-ESP8266模块
 * 输入  ：无
 * 返回  : 无
 * 调用  ：被 ESP8266_AT_Test 调用
 ――――――――――――――――――*/
void ESP8266_Rst ( void )
{
	#if 0
		ESP8266_Cmd ("AT+RST", "OK", "ready", 2500 );   	
	#else
		ESP8266_RST_LOW_LEVEL();
		delay_ms( 500 ); 
		ESP8266_RST_HIGH_LEVEL();
	#endif
}

/*――――――――――――――――――――――――――――――
 * 函数名：ESP8266_Cmd
 * 描述  ：对WF-ESP8266模块发送AT指令
 * 输入  ：cmd，待发送的指令
 *         reply1，reply2，期待的响应，为NULL表不需响应，两者为或逻辑关系
 *         waittime，等待响应的时间
 * 返回  : 1，指令发送成功
 *         0，指令发送失败
 * 调用  ：被外部调用
 ――――――――――――――――――――――――――――――*/
bool ESP8266_Cmd( char* cmd, char* reply1, char* reply2, u32 waittime )
{    
	strEsp8266_Fram_Record .InfBit .FramLength = 0; //从新开始接收新的数据包
	ESP8266_Usart("%s\r\n", cmd );
	if ( ( reply1 == 0 ) && ( reply2 == 0 ) )  //不需要接收数据
		return true;
	delay_ms(waittime);  //延时
	strEsp8266_Fram_Record.Data_RX_BUF[strEsp8266_Fram_Record .InfBit .FramLength] = '\0';
	printf("%s", strEsp8266_Fram_Record .Data_RX_BUF ); 
	if ( ( reply1 != 0 ) && ( reply2 != 0 ) )
		return ( ( bool ) strstr ( strEsp8266_Fram_Record .Data_RX_BUF, reply1 ) || 
				( bool ) strstr ( strEsp8266_Fram_Record .Data_RX_BUF, reply2 ) ); 
	else if ( reply1 != 0 )
		return ( ( bool ) strstr ( strEsp8266_Fram_Record .Data_RX_BUF, reply1 ) );
	else
		return ( ( bool ) strstr ( strEsp8266_Fram_Record .Data_RX_BUF, reply2 ) );	
}


/*―――――――――――――――――――――
 * 函数名：ESP8266_AT_Test
 * 描述  ：对WF-ESP8266模块进行AT测试启动
 * 输入  ：无
 * 返回  : 无
 * 调用  ：被外部调用
 ―――――――――――――――――――――*/
void ESP8266_AT_Test(void)
{
	char count = 0;
	
	ESP8266_RST_HIGH_LEVEL();	
	delay_ms(1000);
	while ( count < 10 )
	{
		if(ESP8266_Cmd ( "AT", "OK", NULL, 500 ) ) return;
		ESP8266_Rst();
		++count;
	}
}

/*――――――――――――――――――――
 * 函数名：ESP8266_Net_Mode_Choose
 * 描述  ：选择WF-ESP8266模块的工作模式
 * 输入  ：enumMode，工作模式
 * 返回  : 1，选择成功
 *         0，选择失败
 * 调用  ：被外部调用
 ――――――――――――――――――――*/
bool ESP8266_Net_Mode_Choose(ENUM_Net_ModeTypeDef enumMode )
{
	switch ( enumMode )
	{
		case STA:
			return ESP8266_Cmd( "AT+CWMODE=1", "OK", "no change", 2500 ); 
		case AP:
			return ESP8266_Cmd( "AT+CWMODE=2", "OK", "no change", 2500 ); 
		case STA_AP:
			return ESP8266_Cmd( "AT+CWMODE=3", "OK", "no change", 2500 ); 
		default:
			return false;
  }
}

/*―――――――――――――――――――
 * 函数名：ESP8266_JoinAP
 * 描述  ：WF-ESP8266模块连接外部WiFi
 * 输入  ：pSSID，WiFi名称字符串
 *       ：pPassWord，WiFi密码字符串
 * 返回  : 1，连接成功
 *         0，连接失败
 * 调用  ：被外部调用
 ―――――――――――――――――――*/
bool ESP8266_JoinAP( char * pSSID, char * pPassWord )
{
	char cCmd [120];

	sprintf( cCmd, "AT+CWJAP=\"%s\",\"%s\"", pSSID, pPassWord );
	return ESP8266_Cmd( cCmd, "OK", NULL, 5000 );
}

/*――――――――――――――――――――――
 * 函数名：ESP8266_Enable_MultipleId
 * 描述  ：WF-ESP8266模块启动多连接
 * 输入  ：enumEnUnvarnishTx，配置是否多连接
 * 返回  : 1，配置成功
 *         0，配置失败
 * 调用  ：被外部调用
 ――――――――――――――――――――――*/
bool ESP8266_Enable_MultipleId( FunctionalState enumEnUnvarnishTx )
{
	char cStr [20];
	
	sprintf( cStr, "AT+CIPMUX=%d", ( enumEnUnvarnishTx ? 1 : 0 ) );
	return ESP8266_Cmd( cStr, "OK", 0, 500 );
	
}

/*――――――――――――――――――――
 * 函数名：ESP8266_Link_Server
 * 描述  ：WF-ESP8266模块连接外部服务器
 * 输入  ：enumE，网络协议
 *       ：ip，服务器IP字符串
 *       ：ComNum，服务器端口字符串
 *       ：id，模块连接服务器的ID
 * 返回  : 1，连接成功
 *         0，连接失败
 * 调用  ：被外部调用
 ――――――――――――――――――――*/
bool ESP8266_Link_Server( ENUM_NetPro_TypeDef enumE, char * ip, char * ComNum, ENUM_ID_NO_TypeDef id)
{
	char cStr [100] = { 0 }, cCmd [120];

	switch( enumE )
	{
		case enumTCP:
		  sprintf( cStr, "\"%s\",\"%s\",%s", "TCP", ip, ComNum ); break;
		case enumUDP:
		  sprintf( cStr, "\"%s\",\"%s\",%s", "UDP", ip, ComNum ); break;
		default:
			break;
	}
	if ( id < 5 )
		sprintf ( cCmd, "AT+CIPSTART=%d,%s", id, cStr);
	else
	  sprintf( cCmd, "AT+CIPSTART=%s", cStr );

	return ESP8266_Cmd( cCmd, "OK", "ALREAY CONNECT", 4000 );	
}

/*――――――――――――――――――――
 * 函数名：ESP8266_UnvarnishSend
 * 描述  ：配置WF-ESP8266模块进入透传发送
 * 输入  ：无
 * 返回  : 1，配置成功
 *         0，配置失败
 * 调用  ：被外部调用
 ――――――――――――――――――――*/
bool ESP8266_UnvarnishSend(void)
{
	if ( ! ESP8266_Cmd ( "AT+CIPMODE=1", "OK", 0, 500 ) )
		return false;
	return 
	  ESP8266_Cmd ( "AT+CIPSEND", "OK", ">", 500 );
}

/*―――――――――――――――――――――――――――
 * 函数名：ESP8266_SendString
 * 描述  ：WF-ESP8266模块发送字符串
 * 输入  ：enumEnUnvarnishTx，声明是否已使能了透传模式
 *       ：pStr，要发送的字符串
 *       ：ulStrLength，要发送的字符串的字节数
 *       ：ucId，哪个ID发送的字符串
 * 返回  : 1，发送成功
 *         0，发送失败
 * 调用  ：被外部调用
 ―――――――――――――――――――――――――――*/
bool ESP8266_SendString( FunctionalState enumEnUnvarnishTx, char * pStr, u32 ulStrLength, ENUM_ID_NO_TypeDef ucId )
{
	char cStr [20];
	bool bRet = false;
		
	if ( enumEnUnvarnishTx )
	{
		ESP8266_Usart( "%s", pStr );
		bRet = true;
	}
	else
	{
		if ( ucId < 5 )
			sprintf( cStr, "AT+CIPSEND=%d,%d", ucId, ulStrLength + 2 );
		else
			sprintf( cStr, "AT+CIPSEND=%d", ulStrLength + 2 );
		ESP8266_Cmd( cStr, "> ", 0, 1000 );
		bRet = ESP8266_Cmd( pStr, "SEND OK", 0, 1000 );
  }
	return bRet;
}

/*―――――――――――――――――――――
 * 函数名：ESP8266_ExitUnvarnishSend
 * 描述  ：配置WF-ESP8266模块退出透传模式
 * 输入  ：无
 * 返回  : 无
 * 调用  ：被外部调用
 ―――――――――――――――――――――*/
void ESP8266_ExitUnvarnishSend ( void )
{
	delay_ms ( 1000 );
	ESP8266_Usart("+++");
	delay_ms ( 500 ); 
}

/*――――――――――――――――――――――――――
 * 函数名：ESP8266_Get_LinkStatus
 * 描述  ：获取 WF-ESP8266 的连接状态，较适合单端口时使用
 * 输入  ：无
 * 返回  : 2，获得ip
 *         3，建立连接
 *         3，失去连接
 *         0，获取状态失败
 * 调用  ：被外部调用
 ――――――――――――――――――――――――――*/
uint8_t ESP8266_Get_LinkStatus ( void )
{
	if ( ESP8266_Cmd("AT+CIPSTATUS", "OK", 0, 500) )
	{
		if ( strstr(strEsp8266_Fram_Record .Data_RX_BUF, "STATUS:2\r\n") )
			return 2; 
		else if ( strstr(strEsp8266_Fram_Record .Data_RX_BUF, "STATUS:3\r\n") )
			return 3;
		else if ( strstr(strEsp8266_Fram_Record .Data_RX_BUF, "STATUS:4\r\n") )
			return 4; 
	}
	return 0;
}


/*
WIFI模块的STA模式，作为TCP Cilent连接TCP Server，并发送数据
*/
void ESP8266_StaTcpClient_Test(void)
{
	uint8_t  ucStatus;
	uint16_t ADC_ConvertedValue;
	float CO_mg_m3 = 0.0;	//用于临时存放CO浓度值
	float tmp = 0.0;  		//用于临时存取温度值
	char  cStr[400] = {0};
	DHT11_Data_TypeDef  DHT11_Data;   //用于存取湿度值
	pms_data_typedef    PMS5003_Data;
	
	printf ("\r\n正在配置 ESP8266 ......\r\n" );
	ESP8266_AT_Test();
	ESP8266_Net_Mode_Choose(STA);
    while( !ESP8266_JoinAP( macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd ) );	
	ESP8266_Enable_MultipleId( DISABLE );
	while ( !ESP8266_Link_Server( enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpServer_Port, Single_ID_0 ) );
	while ( !ESP8266_UnvarnishSend() );
	printf( "\r\n配置 ESP8266 完毕\r\n" );
	while(1)
	{	
		tmp = DS18B20_Get_temperature( );
		Read_PMS5003( &PMS5003_Data );
		ADC_ConvertedValue = Get_Adc_Average( ADC_Channel_11, 10 );	
		if(ADC_ConvertedValue >= 4095)		
			ADC_ConvertedValue = 4095;		
		CO_mg_m3 = (ADC_ConvertedValue-480.0)*((1145.6)/(4095.0-480.0));
		if ( CO_mg_m3 > 1145.6 )
			CO_mg_m3 = 1145.6;

		if (Read_DHT11(&DHT11_Data))
		{
			sprintf(cStr, "%0.2f %0.2f %d.%d %d %d %d %d %d %d %d %d %d %d %d %d ", tmp, CO_mg_m3, \
			DHT11_Data.humi_int, DHT11_Data.humi_deci, \
			PMS5003_Data.PM1dot0CF1, PMS5003_Data.PM2dot5CF1, PMS5003_Data.PM10dot0CF1,\
			PMS5003_Data.PM1dot0, PMS5003_Data.PM2dot5, PMS5003_Data.PM10dot0,\
			PMS5003_Data.Particles0dot3, PMS5003_Data.Particles0dot5, PMS5003_Data.Particles1dot0, \
			PMS5003_Data.Particles2dot5, PMS5003_Data.Particles5dot0, PMS5003_Data.Particles10);
		}
		
		ESP8266_SendString(ENABLE, cStr, 0, Single_ID_0); //发送温度信息到网络调试助手
		delay_ms(1000);
		
		if ( ucTcpClosedFlag ) //检测是否失去连接
		{
			ESP8266_ExitUnvarnishSend();  //退出透传模式
			do ucStatus = ESP8266_Get_LinkStatus(); //获取连接状态
			while ( !ucStatus );
			if ( ucStatus == 4 )  //确认失去连接后重连
			{
				printf("\r\n正在重连热点和服务器 ......\r\n");
				while ( !ESP8266_JoinAP(macUser_ESP8266_ApSsid, macUser_ESP8266_ApPwd) );
				while ( !ESP8266_Link_Server(enumTCP, macUser_ESP8266_TcpServer_IP, macUser_ESP8266_TcpServer_Port, Single_ID_0) );
				printf ( "\r\n重连热点和服务器成功\r\n" );
			}
			while ( !ESP8266_UnvarnishSend() );		
		}
	}
}




